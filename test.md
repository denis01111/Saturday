# Домашнее задание

**Markdown** — *это облегченный язык разметки с синтаксисом форматирования обычного текста.*

>[!NOTE] **Markdown** имеет специальное расширение для оповещений, которое используется для создания блоков цитирования.

Поддерживаются следующие типы оповещений:

> [!NOTE] Информация, которую пользователь должен заметить даже при беглом просмотре.

> [!TIP] Дополнительные сведения, помогающие пользователю лучше решить задачу.

> [!IMPORTANT] Важные сведения для успешного решения задачи.

> [!CAUTION] негативные действия
> [!CAUTION] Потенциальные негативные последствия действия.

> [!WARNING]

## Апострофы и кавычки
Если вы копируете текст из Word в редактор Markdown, он может содержать книжные (изогнутые) апострофы или кавычки. Их нужно заменить кодом или обычными апострофами или кавычками. В противном случае после публикации файла может отобразиться нечитаемый текст, например Itâ€™s.

Ниже приведены кодировки для этих знаков пунктуации:

*левая (открывающая) кавычка*: &#8220;;

*правая (закрывающая) кавычка*: &#8221;;

*правая закрывающая одинарная кавычка или апостроф*: &#8217;;

*левая открывающая одинарная кавычка (используется редко):* &#8216;

**Полужирное** и *курсивное начертания*

Чтобы задать для текста полужирное начертание, заключите его в двойные звездочки:

**Markdown**

Чтобы задать для текста **курсивное начертание**, заключите его в одинарные звездочки:

**Markdown**


Чтобы задать для текста ***полужирное и курсивное начертание***, заключите его в тройные звездочки:

***Markdown***

# HTML
> Хотя Markdown поддерживает встроенный HTML-код, HTML не рекомендуется использовать для публикации на сайте Документации. Любой код, за исключением ограниченного списка значений, будет вызывать появление ошибок и предупреждений при сборке.

***Базовый синтаксис Markdown для внедрения изображения:***

`![alt text for image](default.jpg)`

![alt text for image](default.jpg)


# Удаленные репозитории

Для совместной работы над проектами Git требуются навыки управления удаленными репозиториями. Удаленные репозитории представляют собой версии проекта,
хранимые в Интернете или где-то в сети. Их может быть несколько, и каждый в
общем случае доступен вам только для чтения или же для чтения и записи. Вы
должны уметь отправлять данные в удаленный репозиторий и извлекать их оттуда
каждый раз, когда требуется обменяться результатами работы. Кроме того, вы должны знать, как добавить удаленный репозиторий, как удалить репозиторий, который
больше не используется, как управлять различными удаленными ветками и делать
их отслеживаемыми и неотслеживаемыми, и многое другое. В данном разделе мы
рассмотрим некоторые из этих приемов.

#### Отображение удаленных репозиториев

Просмотр уже настроенных удаленных серверов осуществляется командой git
remote. Она дает список коротких имен для всех указанных вами областей удаленной работы. Если репозиторий был клонирован, вы должны увидеть по крайней
мере источник, то есть имя, которое Git по умолчанию присваивает клонируемому
серверу:
 > git clone https://github.com/schacon/ticgit  
> Cloning into 'ticgit'...  
> remote: Reusing existing pack: 1857, done.  
> remote: Total 1857 (delta 0), reused 0 (delta 0)  
>Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.  
>    Resolving deltas: 100% (772/772), done.  
>    Checking connectivity... done.  
>    $ cd ticgit  
>    $ git remote  
>    origin

Параметр -v позволяет увидеть URL-адреса, которые Git хранит для сокращенного имени, используемого при чтении из данного удаленного репозитория и при
записи в него:
>$ git remote -v  
>Origin https://github.com/schacon/ticgit (fetch)  
>Origin https://github.com/schacon/ticgit (push)  

Если репозиториев несколько, они выводятся списком. Скажем, репозиторий
с несколькими удаленными копиями для совместной работы с коллегами может
выглядеть следующим образом.
> \$cd grit  
$ git remote -v  
bakkdoor https://github.com/bakkdoor/grit (fetch)  
bakkdoor https://github.com/bakkdoor/grit (push)  
cho45 https://github.com/cho45/grit (fetch)  
cho45 https://github.com/cho45/grit (push)  
defunkt https://github.com/defunkt/grit (fetch)  
defunkt https://github.com/defunkt/grit (push)  
koke git://github.com/koke/grit.git (fetch)  
koke git://github.com/koke/grit.git (push)  
origin git@github.com:mojombo/grit.git (fetch)  
origin git@github.com:mojombo/grit.git (push)  

Это означает, что мы легко можем скачать себе изменения, внесенные любым
из этих пользователей. При этом у нас может быть допуск на запись в один или
несколько репозиториев из списка, хотя представленный код данную деталь не
показывает.
Обратите внимание, что эти удаленные репозитории пользуются разными протоколами; впрочем, детально эта тема рассматривается в главе 4.

### Добавление удаленных репозиториев

Ранее уже не раз упоминался и демонстрировался процесс добавления удаленных
репозиториев, но теперь мы рассмотрим его в явном виде. Чтобы добавить такой
репозиторий под коротким именем, которое упростит дальнейшие обращения к
нему, используйте команду *git remote add [сокращенное имя] [url]*. 

Вот как добавить репозиторий коллеги Пола:

>\$ _git remote  
origin  
\$ git remote add pb https://github.com/paulboone/ticgit  
$ git remote -v  
origin https://github.com/schacon/ticgit (fetch)  
origin https://github.com/schacon/ticgit (push)  
pb https://github.com/paulboone/ticgit (fetch)  
pb https://github.com/paulboone/ticgit (push)_

Теперь вместо полного URL-адреса в командную строку можно вводить имя pb.
К примеру, для скачивания всей информации, которая есть у коллеги, но отсутствует
у вас, используйте команду *git fetch pb:*

> \$ git fetch pb  
remote: Counting objects: 43, done.  
remote: Compressing objects: 100% (36/36), done.  
remote: Total 43 (delta 10), reused 31 (delta 5)  
Unpacking objects: 100% (43/43), done.  
From *https://github.com/paulboone/ticgit*  
\* [new branch] master -> pb/master  
\* [new branch] ticgit -> pb/ticgit

Ветка *master* этого коллеги теперь доступна вам локально как *pb/master*. Вы можете выполнить ее слияние с одной из ваших веток или перейти в нее, если требуется просто проверить ее содержимое. (Ветви и работа с ними подробно рассматриваются в главе 3.)

## Извлечение данных из удаленных репозиториев

Как вы уже видели, извлечение данных из удаленных проектов выполняется такой
командой:

> $ git fetch [имя удаленного репозитория]

Эта команда связывается с удаленным проектом и извлекает оттуда все пока
отсутствующие у вас данные. После этого у вас должны появиться ссылки на
все ветки удаленного проекта, которые можно подвергнуть слиянию или просмотреть.

При клонировании данная команда автоматически добавляет удаленный репозиторий под именем «origin». Соответственно команда **git fetch origin** извлекает
все, что появилось на этом сервере после его клонирования (или после момента
последнего извлечения информации). Важно понимать, что команда **git fetch**
помещает все данные в ваш локальный репозиторий, — она не выполняет автоматическое слияние с ветками, с которыми вы работаете в данный момент, и вообще никак не затрагивает эти ветки. Слияние вы выполните вручную, как только в этом возникнет необходимость.

Если же у вас есть ветка, настроенная на слежение за какой-то удаленной веткой (подробно эта операция рассматривается в главе 3), команда *git pull* будет автоматически извлекать информацию из удаленной ветки и выполнять слияние с текущей веткой. В некоторых случаях такой порядок вещей оказывается
проще и удобнее; кроме того, по умолчанию команда *git clone* автоматически
настраивает вашу локальную ветку *master* на слежение за удаленной веткой
*master* (она может иметь и другое имя) на сервере, с которого вы выполняли
клонирование. В общем случае команда *git pull* извлекает данные с сервера,
который вы клонировали, и автоматически пытается слить их с вашим текущим
рабочим кодом.

## Отправка данных в удаленный репозиторий

Чтобы поделиться результатами своего труда, их нужно отправить в репозиторий.
Это делается простой командой **git push [имя удаленного сервера] [ветка]**. Для
отправки ветки *master* на сервер *origin* (еще раз напоминаем, что в процессе клонирования эти имена присваиваются автоматически) следует написать:

>$ git push origin master

Команда сработает только при условии, что клонирование осуществлялось с сервера, где у вас есть доступ на запись, и за это время никто не отправлял туда свои
данные. Если вы выполнили клонирование одновременно с другим пользователем
и он уже отправил результаты своей работы на сервер, ваша попытка отправки
данных окончится неудачей. Вам сначала нужно скачать все добавленное этим
пользователем и встроить это в свои данные, и только после этого появится возможность воспользоваться командой *push*. Более подробно процесс отправки данных
на удаленные серверы рассматривается в главе 3.
